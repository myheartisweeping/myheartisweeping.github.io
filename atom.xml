<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>驼城飞龙</title>
  
  <subtitle>龙哥的博客</subtitle>
  <link href="/atom.xml" rel="self"/>
  
  <link href="http://yoursite.com/"/>
  <updated>2020-01-26T11:03:51.901Z</updated>
  <id>http://yoursite.com/</id>
  
  <author>
    <name>Bruce</name>
    
  </author>
  
  <generator uri="http://hexo.io/">Hexo</generator>
  
  <entry>
    <title>学习记录</title>
    <link href="http://yoursite.com/2020/01/25/%E5%AD%A6%E4%B9%A0%E8%AE%B0%E5%BD%95/"/>
    <id>http://yoursite.com/2020/01/25/学习记录/</id>
    <published>2020-01-25T06:57:27.000Z</published>
    <updated>2020-01-26T11:03:51.901Z</updated>
    
    <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><script class="meting-secondary-script-marker" src="\assets\js\Meting.min.js"></script><h2 id="函数指针"><a href="#函数指针" class="headerlink" title="函数指针"></a>函数指针</h2><p>　　函数指针是指向函数的指针变量。所以，函数指针首先是一个指针变量，而且这个指针变量指向一个函数。C++在编译时，每一个函数都有一个入口地址，该入口地址就是函数指针所指向的地址。有了指向函数的指针变量后，就可以用该指针变量调用函数了。</p><p>　　函数指针的声明方式是：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">返回值类型 （*指针变量名)([形参列表])；</span><br></pre></td></tr></table></figure><p>　　其中，返回值类型说明函数的返回值类型，（＊指针变量名）这句的括号不能省略。例如：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">func</span><span class="params">(<span class="keyword">int</span> a)</span></span>;               <span class="comment">//声明一个函数</span></span><br><span class="line"><span class="keyword">int</span> (*f) (<span class="keyword">int</span> a);              <span class="comment">//声明一个函数指针</span></span><br><span class="line">f = &amp;func;</span><br></pre></td></tr></table></figure><p>　　将func函数的首地址赋值给函数指针，这里也等价于f = &amp;func；赋值时函数不带括号，也不带参数，函数名就代表了函数的首地址。下面展示了函数指针调用函数的方法。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">Mmin</span><span class="params">(<span class="keyword">int</span> x, <span class="keyword">int</span> y)</span></span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(x &lt; y) <span class="keyword">return</span> x;</span><br><span class="line">    <span class="keyword">return</span> y;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">Mmax</span><span class="params">(<span class="keyword">int</span> x, <span class="keyword">int</span> y)</span></span>&#123;</span><br><span class="line"><span class="keyword">if</span>(x &gt; y) <span class="keyword">return</span> x;</span><br><span class="line">    <span class="keyword">return</span> y;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> (*f)(<span class="keyword">int</span> x, <span class="keyword">int</span> y);</span><br><span class="line">    <span class="keyword">int</span> a = <span class="number">10</span>, b = <span class="number">20</span>;</span><br><span class="line">    f = Mmin;                           <span class="comment">//把Mmin函数的入口地址赋给f</span></span><br><span class="line">    <span class="built_in">cout</span> &lt;&lt; (*f)(a, b) &lt;&lt; <span class="built_in">endl</span>;      </span><br><span class="line">    f = Mmax;                           <span class="comment">//把Mmax函数的入口地址赋给f</span></span><br><span class="line">    <span class="built_in">cout</span> &lt;&lt; (*f)(a, b) &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">运行的结果为：</span><br><span class="line"><span class="number">10</span></span><br><span class="line"><span class="number">20</span></span><br></pre></td></tr></table></figure><p>本文内容取自《后台开发核心技术与应用实践》徐晓鑫 著</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;link rel=&quot;stylesheet&quot; class=&quot;aplayer-secondary-style-marker&quot; href=&quot;\assets\css\APlayer.min.css&quot;&gt;&lt;script src=&quot;\assets\js\APlayer.min.js&quot; cla
      
    
    </summary>
    
      <category term="学习笔记" scheme="http://yoursite.com/categories/%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/"/>
    
    
      <category term="C++" scheme="http://yoursite.com/tags/C/"/>
    
  </entry>
  
  <entry>
    <title>2020新年帖</title>
    <link href="http://yoursite.com/2020/01/24/2020%E6%96%B0%E5%B9%B4%E5%B8%96/"/>
    <id>http://yoursite.com/2020/01/24/2020新年帖/</id>
    <published>2020-01-24T08:24:08.000Z</published>
    <updated>2020-01-25T06:41:34.364Z</updated>
    
    <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><script class="meting-secondary-script-marker" src="\assets\js\Meting.min.js"></script><h2 id="2020年新年寄语"><a href="#2020年新年寄语" class="headerlink" title="2020年新年寄语"></a><center>2020年新年寄语</center></h2><p>　　今天是2020年的第一天。回首2019年，真是若白驹过隙，倏忽而已。过去的一年虽有收获，但更多的却是失意。心情也比较低迷。但是也从中学习到很多经验和教训。</p><p>　　新的一年应该重振旗鼓，开启一段新的旅程。希望在新的一年里学业顺利，家人健健康康，平平安安。武汉新型冠状病毒的出现也牵动了全国人民的心，希望我们每个人都做好防御措施，早日打赢这场战争，武汉加油，祖国加油！</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;link rel=&quot;stylesheet&quot; class=&quot;aplayer-secondary-style-marker&quot; href=&quot;\assets\css\APlayer.min.css&quot;&gt;&lt;script src=&quot;\assets\js\APlayer.min.js&quot; cla
      
    
    </summary>
    
      <category term="浮生日记" scheme="http://yoursite.com/categories/%E6%B5%AE%E7%94%9F%E6%97%A5%E8%AE%B0/"/>
    
    
      <category term="life" scheme="http://yoursite.com/tags/life/"/>
    
  </entry>
  
  <entry>
    <title>LeetCode-09</title>
    <link href="http://yoursite.com/2019/11/08/LeetCode-09/"/>
    <id>http://yoursite.com/2019/11/08/LeetCode-09/</id>
    <published>2019-11-08T08:40:09.000Z</published>
    <updated>2020-01-24T08:21:38.686Z</updated>
    
    <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><script class="meting-secondary-script-marker" src="\assets\js\Meting.min.js"></script><p>今天的题目是一道关于正则匹配的题目，给定一个输入字符串s和一个模式p，判断二者是否相同。<a id="more"></a></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">Given an input string (s) and a pattern (p), implement regular expression matching with support &apos;.&apos;  and &apos;*&apos;.</span><br><span class="line">&apos;.&apos; Matches any single character.</span><br><span class="line">&apos;*&apos; Matches zeros or more of the preceding element.</span><br><span class="line">The matching should cover the entire input string (not partial).</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;今天的题目是一道关于正则匹配的题目，给定一个输入字符串s和一个模式p，判断二者是否相同。
    
    </summary>
    
      <category term="学习笔记" scheme="http://yoursite.com/categories/%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/"/>
    
    
      <category term="LeetCode" scheme="http://yoursite.com/tags/LeetCode/"/>
    
      <category term="C++" scheme="http://yoursite.com/tags/C/"/>
    
  </entry>
  
  <entry>
    <title>LeetCode-08</title>
    <link href="http://yoursite.com/2019/11/07/LeetCode-08/"/>
    <id>http://yoursite.com/2019/11/07/LeetCode-08/</id>
    <published>2019-11-07T02:56:38.000Z</published>
    <updated>2019-11-07T15:37:43.196Z</updated>
    
    <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><script class="meting-secondary-script-marker" src="\assets\js\Meting.min.js"></script><p>今天的题目是实现字符串到整数的函数(atoi)。<a id="more"></a>给定的字符串中包含空格，以及非数值字符。第一个出现的非空格字符表示数值的符号。如果不能进行转换，即不存在数值，则返回0。测试用例如下所示：</p><p><strong>Note:</strong></p><ul><li>Only the space character ‘ ‘ is considered as whitespace character.</li><li>Assume we are dealing with an environment which could only store integers within the 32-bit signed integer range: $[(-2)^{31}, 2^{31}-1]$, if the numerical value is out of the range of representable values, INT_MAX $(2^{31}-1)$ or INT_MIN $(-2^{31})$ is returned.</li></ul><p><strong>Example 1: </strong></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">Input: &quot;42&quot;</span><br><span class="line">Output: 42</span><br></pre></td></tr></table></figure><p><strong>Example 2:</strong></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">Input: &quot;    -42&quot;</span><br><span class="line">Output: -42</span><br><span class="line">Explanation: The first non-whitespace character is &apos;-&apos;, which is the minus sign. Then take as many              numerical digits as possible, which gets 42.</span><br></pre></td></tr></table></figure><p><strong>Example 3:</strong></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">Input: &quot;4193 with words&quot;</span><br><span class="line">Output: 4193</span><br><span class="line">Explanation: Conversion stops at digit &apos;3&apos; as the next character is not a numerical digit.</span><br></pre></td></tr></table></figure><p><strong>Example 4:</strong></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">Input: &quot;words and 987&quot;</span><br><span class="line">Output: 0</span><br><span class="line">Explanation: The first non-whitespace character is &apos;w&apos;, which is not a numerical digit or a +/-                  sign. Therefore no valid conversion could be performed.</span><br></pre></td></tr></table></figure><p><strong>Example 5:</strong></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">Input: &quot;-91283472332&quot;</span><br><span class="line">Output: -2147483648</span><br><span class="line">Explanation: The number &quot;-91283472332&quot; is out of the range of a 32-bit signed integer. Therefore                INT_MIN is returned.</span><br></pre></td></tr></table></figure><h2 id="解题思路"><a href="#解题思路" class="headerlink" title="解题思路"></a>解题思路</h2><p>本题较为简单，对于给定的字符串，我们依次遍历字符串，去掉前导空格后，遇到第一个非空字符，判断其正负号。然后继续遍历下去，直到遇到非数值字符。具体代码如下所示：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>&#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">myAtoi</span><span class="params">(<span class="built_in">string</span> str)</span></span>&#123;</span><br><span class="line">        <span class="keyword">int</span> len = str.length();</span><br><span class="line">        <span class="keyword">int</span> i = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span>(i = <span class="number">0</span>; i &lt; len; i++)&#123; <span class="comment">//discard whitespace</span></span><br><span class="line">            <span class="keyword">if</span>(str[i] != <span class="string">' '</span>)&#123;</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">bool</span> symbol = <span class="literal">false</span>; <span class="comment">// if negative, symbol = true</span></span><br><span class="line">        <span class="keyword">if</span>(str[i] == <span class="string">'-'</span>)&#123;</span><br><span class="line">            symbol = <span class="literal">true</span>;</span><br><span class="line">            i++;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span>(str[i] == <span class="string">'+'</span>)&#123;</span><br><span class="line">            i++;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">long</span> <span class="keyword">int</span> result = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> j = i; j &lt; len; j++)&#123;</span><br><span class="line">            <span class="keyword">if</span>(<span class="built_in">isdigit</span>(str[j]))&#123;</span><br><span class="line">                result = result * <span class="number">10</span> + str[j];</span><br><span class="line">                <span class="keyword">if</span>(symbol &amp;&amp; -result &lt; INT_MIN)&#123;</span><br><span class="line">                    <span class="keyword">return</span> INT_MIN;</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="keyword">else</span> <span class="keyword">if</span>(!symbol &amp;&amp; result &gt; INT_MAX)&#123;</span><br><span class="line">                    <span class="keyword">return</span> INT_MAX;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">else</span>&#123;</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span>(symbol)&#123;</span><br><span class="line">            <span class="keyword">return</span> -result;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span>&#123;</span><br><span class="line">            <span class="keyword">return</span> result;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;今天的题目是实现字符串到整数的函数(atoi)。
    
    </summary>
    
      <category term="学习笔记" scheme="http://yoursite.com/categories/%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/"/>
    
    
      <category term="LeetCode" scheme="http://yoursite.com/tags/LeetCode/"/>
    
      <category term="C++" scheme="http://yoursite.com/tags/C/"/>
    
  </entry>
  
  <entry>
    <title>leetcode-07</title>
    <link href="http://yoursite.com/2019/11/05/LeetCode-07/"/>
    <id>http://yoursite.com/2019/11/05/LeetCode-07/</id>
    <published>2019-11-05T09:38:11.000Z</published>
    <updated>2019-11-06T14:58:56.983Z</updated>
    
    <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><script class="meting-secondary-script-marker" src="\assets\js\Meting.min.js"></script><p>　　以人为镜，可以知不足。翻阅优秀的人所写的文章和博客，会愈发的看到自己的无知和肤浅。可不论多么优秀的人，都离不开一点一滴的努力。所以，不足不可怕，可怕的是看不到。对于算法的学习，切不能求于表面，而应深入理解，将其化为自身所有。<a id="more"></a></p><p>　　今天的题目是ZigZag转换，将ZigZag描述的字符串按行顺序读出。题目描述如下：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">The string &quot;PAYPALISHIRING&quot; is written in a zigzag pattern on a given number of rows like  this:</span><br><span class="line">P   A   H   N</span><br><span class="line">A P L S I I G</span><br><span class="line">Y   I   R</span><br><span class="line">And then read line by line: &quot;PAHNAPLSIIGYIG&quot;</span><br><span class="line">Write the code that will take a string and make this conversion given a number of rows:</span><br><span class="line">string convert(string s, int numRows);</span><br></pre></td></tr></table></figure><p><strong>Example 1:</strong></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">Input: s = &quot;PAYPALISHIRING&quot;, numRows = 3</span><br><span class="line">Output: “PAHNAPLSIIGYIG&quot;</span><br></pre></td></tr></table></figure><p><strong>Example 2:</strong></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">Input: s = &quot;PAYPALISHIRING&quot;, numRows = 4</span><br><span class="line">Output: &quot;PINALSIGYAHRPI&quot;</span><br></pre></td></tr></table></figure><h2 id="解法一"><a href="#解法一" class="headerlink" title="解法一"></a>解法一</h2><p>本题的第一思路是按照顺序去遍历整个字符串，即按照顺序分别将字符放置到对应的行中。我们需要设置一个变量来指示现在的方向，为1的时候表示向下，为-1的时候表示向上。代码如下所示：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="built_in">string</span> <span class="title">convert</span><span class="params">(<span class="built_in">string</span> s, <span class="keyword">int</span> numRows)</span></span>&#123;</span><br><span class="line">        <span class="keyword">int</span> n = s.length();</span><br><span class="line">        <span class="keyword">if</span>(n &lt;= <span class="number">1</span> || numRows &lt;= <span class="number">1</span>)&#123;</span><br><span class="line">            <span class="keyword">return</span> s;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="built_in">vector</span>&lt;<span class="built_in">string</span>&gt; result(numRows);</span><br><span class="line">        <span class="built_in">string</span> ans;</span><br><span class="line">        <span class="keyword">int</span> direct = <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">int</span> row = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; n; i++)&#123;</span><br><span class="line">            result[row] += s[i];</span><br><span class="line">            row += direct;</span><br><span class="line">            <span class="keyword">if</span>(row == numRows)&#123;</span><br><span class="line">                row = numRows - <span class="number">2</span>;</span><br><span class="line">                direct = <span class="number">-1</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span>(row &lt; <span class="number">0</span>)&#123;</span><br><span class="line">                row = <span class="number">1</span>;</span><br><span class="line">                direct = <span class="number">1</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; numRows; i++)&#123;</span><br><span class="line">            ans += result[i];</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> ans;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><h2 id="解法二"><a href="#解法二" class="headerlink" title="解法二"></a>解法二</h2><p>解法二的思路是找到对应行与原字符串之间的规律。假设numRows = 3，将对应值列出如下所示：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">string: P A Y P A L I S H I R I N G</span><br><span class="line">row:    1 2 3 2 1 2 3 2 1 2 3 2 1 2</span><br></pre></td></tr></table></figure><p>由上可观察得出，每行出现的周期为2 * nRows - 2</p><p>首行和尾行之间的数据会多出现一次，出现的位置距离本次周期的起始位置为：2 <em> nRows - 2 - 2 </em> i 。</p><p>所以可根据此规律编写代码如下：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="built_in">string</span> <span class="title">convert</span><span class="params">(<span class="built_in">string</span> s, <span class="keyword">int</span> numRows)</span></span>&#123;</span><br><span class="line">        <span class="keyword">int</span> n = s.length();</span><br><span class="line">        <span class="keyword">if</span>(n &lt;= <span class="number">1</span> || numRows &lt;= <span class="number">1</span>)&#123;</span><br><span class="line">            <span class="keyword">return</span> s;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="built_in">string</span> ans;</span><br><span class="line">        <span class="keyword">int</span> lag = <span class="number">2</span>*numRows - <span class="number">2</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; numRows; i++)&#123;</span><br><span class="line">            <span class="keyword">for</span>(<span class="keyword">int</span> j = i; j &lt; len; j += lag)&#123;</span><br><span class="line">                ans += s[j];</span><br><span class="line">                <span class="keyword">if</span>(i &gt; <span class="number">0</span> &amp;&amp; i &lt; numRows<span class="number">-1</span>)&#123;</span><br><span class="line">                    <span class="keyword">int</span> t = j + lag - <span class="number">2</span> * i;</span><br><span class="line">                    <span class="keyword">if</span>(t &lt; len)&#123;</span><br><span class="line">                        ans += s[t];</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> ans;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>本题参考博客：<a href="https://blog.csdn.net/ljiabin/article/details/40477429" target="_blank" rel="noopener">https://blog.csdn.net/ljiabin/article/details/40477429</a></p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;　　以人为镜，可以知不足。翻阅优秀的人所写的文章和博客，会愈发的看到自己的无知和肤浅。可不论多么优秀的人，都离不开一点一滴的努力。所以，不足不可怕，可怕的是看不到。对于算法的学习，切不能求于表面，而应深入理解，将其化为自身所有。
    
    </summary>
    
      <category term="学习笔记" scheme="http://yoursite.com/categories/%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/"/>
    
    
      <category term="LeetCode" scheme="http://yoursite.com/tags/LeetCode/"/>
    
      <category term="C++" scheme="http://yoursite.com/tags/C/"/>
    
  </entry>
  
  <entry>
    <title>LeetCode-06</title>
    <link href="http://yoursite.com/2019/10/08/LeetCode-06/"/>
    <id>http://yoursite.com/2019/10/08/LeetCode-06/</id>
    <published>2019-10-08T12:42:18.000Z</published>
    <updated>2019-11-06T03:25:34.472Z</updated>
    
    <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><script class="meting-secondary-script-marker" src="\assets\js\Meting.min.js"></script><p>　　距离上次博客更新又过去很长时间了，把一件事情坚持下去确实很难。日常的各种计划总会被各种琐事打乱，但归根结底还是自己缺乏一种定力。并且每天的有效工作时间不足，自己的内心不能沉淀下来，总会心烦意乱。可人与人之间的距离就是在日常的点点滴滴中产生的，把一件看似简单的事情坚持下去，便可能成就不凡。建立这个博客的初衷是记录自己的学习过程，其实更重要的是反思自己的生活状态和学习状态。<a id="more"></a></p><p>　　写作是一种很好的记录习惯，在写作的过程中能够对自己日常的工作进行一个反思和整理。同时，也能在写作的过程中进一步进行思考，加深对问题的理解。在这里也督促自己能够继续坚持下去，哪怕每天只记录一个知识点，一件小事，也应该去做好。正所谓，不积跬步无以至千里。所以，整理好自己的内心，坚持走下去！</p><p>　　今天继续记录一道LeetCode题目，该题目是给定一个字符串s，找出其中最长的回文子串。题目描述如下：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Given a string s, find the longest palindromic substring in s. You may assume that the maximum length of s is 1000.</span><br></pre></td></tr></table></figure><p><strong>Example 1:</strong></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">Input: &quot;babad&quot;</span><br><span class="line">Output: &quot;bab&quot;</span><br><span class="line">Note: &quot;aba&quot; is also a valid answer.</span><br></pre></td></tr></table></figure><p><strong>Example 2:</strong></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">Input: &quot;cbbd&quot;</span><br><span class="line">Output: &quot;bb&quot;</span><br></pre></td></tr></table></figure><h2 id="解法一"><a href="#解法一" class="headerlink" title="解法一"></a>解法一</h2><p>第一种解法仍然是暴力求解的思路，遍历所有的子串，判断子串是否是回文字符串即可。代码如下所示：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>&#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="built_in">string</span> <span class="title">longestPalindrome</span><span class="params">(<span class="built_in">string</span> s)</span></span>&#123;</span><br><span class="line">        <span class="keyword">int</span> n = s.length();</span><br><span class="line">        <span class="keyword">if</span>(n &lt;= <span class="number">1</span>)&#123;</span><br><span class="line">            <span class="keyword">return</span> s;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="built_in">string</span> ans;</span><br><span class="line">        <span class="keyword">int</span> temp = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; n; i++)&#123;</span><br><span class="line">            <span class="keyword">for</span>(<span class="keyword">int</span> j = i+<span class="number">1</span>; j &lt;=n; j++)&#123;</span><br><span class="line">                <span class="keyword">if</span>(isPalindrome(s, i, j))&#123;</span><br><span class="line">                    <span class="keyword">if</span>((j-i) &gt; temp)&#123;</span><br><span class="line">                        temp = j-i;</span><br><span class="line">                        ans = s.substr(i, (j-i));</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> ans;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">bool</span> <span class="title">isPalindrome</span><span class="params">(<span class="built_in">string</span> s, <span class="keyword">int</span> m, <span class="keyword">int</span> n)</span></span>&#123;</span><br><span class="line">        <span class="built_in">string</span> temp = s.substr(m, (m-n));</span><br><span class="line">        <span class="keyword">int</span> len = temp.length();</span><br><span class="line">        <span class="built_in">string</span> temp1;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; len; i++)&#123;</span><br><span class="line">            temp1 = temp[i] + temp1;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span>(temp = temp1)&#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span>&#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>这种解法虽然是最直接和最简单的方式。但是，当字符串的长度足够长的时候，则无法胜任了。其算法复杂度为$O(n^3)$。我们需要进一步优化算法。</p><h2 id="解法二（动态规划）"><a href="#解法二（动态规划）" class="headerlink" title="解法二（动态规划）"></a>解法二（动态规划）</h2><p>解法二中，优化判断是不是回文子串的算法。在暴力解法中，对于每个子串我们都要从零开始进行判断，这其中存在一些冗余。例如对于字符串”ababa”，当我们知道”bab”是回文的时候，我们只需要判断左右两边的字符是否相等即可。</p><p>我们定义$P(i,j)$如下所示：</p><p>$$P(i,j)=\begin{cases} true&amp; \text{if the substring S_i … S_j is a palindrome} \ false&amp; \text{otherwise} \end{cases}$$</p><p>所以，$P(i, j)=(P(i+1, j-1) and S_i == S_j)$。</p><p>基例是$P(i,i) = true$，$P(i, i+1) = (S_i == S_{i+1})$。</p><p>代码如下所示：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>&#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="built_in">string</span> <span class="title">longestPalindrome</span><span class="params">(<span class="built_in">string</span> s)</span></span>&#123;</span><br><span class="line">        <span class="keyword">int</span> n = s.length();</span><br><span class="line">        <span class="keyword">if</span>(n &lt;= <span class="number">1</span>)&#123;</span><br><span class="line">            <span class="keyword">return</span> s;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">bool</span> dp[n][n];</span><br><span class="line">        <span class="built_in">string</span> ans;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; n; i++)&#123;</span><br><span class="line">            <span class="keyword">for</span>(<span class="keyword">int</span> j = i; j &gt;= <span class="number">0</span>; j++)&#123;</span><br><span class="line">                dp[i][j] = (s[i] == s[j] &amp;&amp; (i-j &lt; <span class="number">3</span> || dp[i<span class="number">-1</span>][j+<span class="number">1</span>]));</span><br><span class="line">                <span class="keyword">if</span>(dp[i][j] &amp;&amp; (ans == <span class="string">""</span> || ans.length() &lt; i-j+<span class="number">1</span>))&#123;</span><br><span class="line">                    ans = s.substr(j, i-j+<span class="number">1</span>);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> ans;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>在编写的过程中一定要注意边界条件，考虑到特殊的测试用例。</p><h2 id="解法三（以中心点展开）"><a href="#解法三（以中心点展开）" class="headerlink" title="解法三（以中心点展开）"></a>解法三（以中心点展开）</h2><p>由于回文字符串是对称的，将每个点作为中心点，向两边扩展，即可找到最长的回文字符串，代码如下所示：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>&#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="built_in">string</span> <span class="title">longestPalindrome</span><span class="params">(<span class="built_in">string</span> s)</span></span>&#123;</span><br><span class="line">        <span class="keyword">int</span> n = s.length();</span><br><span class="line">        <span class="keyword">if</span>(n &lt;= <span class="number">1</span>)&#123;</span><br><span class="line">            <span class="keyword">return</span> s;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">int</span> start = <span class="number">0</span>, end = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; n; i++)&#123;</span><br><span class="line">            <span class="keyword">int</span> len1 = expandAroundCenter(s, i, i);</span><br><span class="line">            <span class="keyword">int</span> len2 = expandAroundCenter(s, i, i+<span class="number">1</span>);</span><br><span class="line">            <span class="keyword">int</span> len = max(len1, len2);</span><br><span class="line">            <span class="keyword">if</span>(len &gt; end - start)&#123;</span><br><span class="line">                start = i - (len - <span class="number">1</span>) / <span class="number">2</span>;</span><br><span class="line">                end = i + len / <span class="number">2</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> s.substr(start, end-start+<span class="number">1</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">expandAroundCenter</span><span class="params">(<span class="built_in">string</span> s, <span class="keyword">int</span> left, <span class="keyword">int</span> right)</span></span>&#123;</span><br><span class="line">        <span class="keyword">int</span> L = left, R = right;</span><br><span class="line">        <span class="keyword">while</span>(L &gt;= <span class="number">0</span> &amp;&amp; R &lt; s.length &amp;&amp; S[L] == S[R])&#123;</span><br><span class="line">            L--;</span><br><span class="line">            R++;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> R-L<span class="number">-1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>还有一种算法，其复杂度为$O(n)$，该算法是Manacher’s Algorithm。我尚未做深入研究，有兴趣的可以自行搜索研究。本文如有错误之处，欢迎指出。</p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;　　距离上次博客更新又过去很长时间了，把一件事情坚持下去确实很难。日常的各种计划总会被各种琐事打乱，但归根结底还是自己缺乏一种定力。并且每天的有效工作时间不足，自己的内心不能沉淀下来，总会心烦意乱。可人与人之间的距离就是在日常的点点滴滴中产生的，把一件看似简单的事情坚持下去，便可能成就不凡。建立这个博客的初衷是记录自己的学习过程，其实更重要的是反思自己的生活状态和学习状态。
    
    </summary>
    
      <category term="学习笔记" scheme="http://yoursite.com/categories/%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/"/>
    
    
      <category term="LeetCode" scheme="http://yoursite.com/tags/LeetCode/"/>
    
      <category term="C++" scheme="http://yoursite.com/tags/C/"/>
    
  </entry>
  
  <entry>
    <title>LeetCode-05</title>
    <link href="http://yoursite.com/2019/10/05/LeetCode-05/"/>
    <id>http://yoursite.com/2019/10/05/LeetCode-05/</id>
    <published>2019-10-05T06:52:41.000Z</published>
    <updated>2019-11-06T02:49:25.548Z</updated>
    
    <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><script class="meting-secondary-script-marker" src="\assets\js\Meting.min.js"></script><p>今天的题目是求两个有序数组的中位数，两个数组的长度分别是 $m$ 和 $n$ 。并要求时间复杂度为 $O(\log(m+n))$。我们假定两个数组均不为空。具体题目如下：<a id="more"></a></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">There are two sorted arrays nums1 and nums2 of size m and n respectively. Find the median of the two sorted arrays. The overall run time complexity should be O(log(m+n)). You may assume nums1 and nums2 cannot be both empty.</span><br></pre></td></tr></table></figure><p><strong>Example 1:</strong></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">nums1 = [1, 3]</span><br><span class="line">nums2 = [2]</span><br><span class="line">The median is 2.0</span><br></pre></td></tr></table></figure><p><strong>Example 2:</strong></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">nums1 = [1, 2]</span><br><span class="line">nums2 = [3, 4]</span><br><span class="line">The median is (2+3)/2 = 2.5</span><br></pre></td></tr></table></figure><h2 id="解法一"><a href="#解法一" class="headerlink" title="解法一"></a>解法一</h2><p>看到这道题，如果不考虑时间复杂度，最简单粗暴的办法就是将两个数组合并为一个数组，合并后的数组长度如果是奇数，则中间的一个数便是中位数，如果长度为偶数，则中位数为中间两个数的均值。代码如下所示：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>&#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">double</span> <span class="title">findMedianSortedArrays</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&amp; nums1, <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&amp; nums2)</span></span>&#123;</span><br><span class="line">        <span class="keyword">int</span> n1 = nums1.size();</span><br><span class="line">        <span class="keyword">int</span> n2 = nums2.size();</span><br><span class="line">        <span class="keyword">int</span> sumLen = n1 + n2;</span><br><span class="line">        <span class="keyword">double</span> ans = <span class="number">0.0</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; n2; i++)&#123;</span><br><span class="line">            nums1.push_back(nums2[i]);</span><br><span class="line">        &#125;</span><br><span class="line">        sort(nums1.begin(), nums1.end());</span><br><span class="line">        <span class="keyword">if</span>(sumLen % <span class="number">2</span> == <span class="number">0</span>)&#123;</span><br><span class="line">            ans = (nums1[sumLen/<span class="number">2</span>] + nums1[sumLen / <span class="number">2</span> <span class="number">-1</span>]) / <span class="number">2.0</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span>&#123;</span><br><span class="line">            ans = nums1[sumLen/<span class="number">2</span>];</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> ans;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><h2 id="解法二"><a href="#解法二" class="headerlink" title="解法二"></a>解法二</h2><p>解法一中的时间消耗一是合并两个数组，二是对数组进行排序，所以算法复杂度主要是由排序算法决定的。同时也没有利用到有序这个信息。所以解法二的思想是将两个数组分别分成左右两个部分，使得左右两部分的长度相等，并且满足左边的最大值小于右边的最小值，即满足下述两条：</p><ol><li>len(left_part) = len(right_part)</li><li>max(left_part) &lt;= min(right_part)</li></ol><p>为满足上述两个条件，我们需要保证以下条件，其中 $i$ 为数组A的分割点，$j$ 为数组B的分割点。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">1. i + j = m - i + n - j(or: m-i+n-j+1)</span><br><span class="line">   if n &gt; m, we just need to set: i=0~m, j = (m+n+1)/2 - i</span><br><span class="line">2. B[j-1] &lt;= A[i] and A[i-1] &lt;= B[j]</span><br></pre></td></tr></table></figure><p>同时，我们要保证 $n &gt; m$ 。因为 $0&lt;=i&lt;=m$ 并且 $j = \frac {m+n+1} {2} - i$ ，所以如果 $n&lt; m$ ,那么$j$ 有可能是负值，这将导致错误的结果。在寻找  $i$ 时，我们使用二分查找，需要考虑三种情况：</p><ul><li><p>$B[j-1]$ &lt;= $A[i]$ and $A[i-1]$ &lt;= $B[j]$</p><p>这意味着我们找到了合适的 $i$ ，停止搜索。</p></li><li><p>$B[j-1] &gt; A[i]$</p><p>这意味着 $i$ 太小，所以我们将 $i$ 的左边界加一。</p></li><li><p>$A[i-1] &gt; B[j]$</p><p>这意味着 $i$ 太大，我们将 $i$ 的右边界减一。</p></li></ul><p>具体c++代码如下所示：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>&#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">double</span> <span class="title">findMedianSortedArrays</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&amp; nums1, <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&amp; nums2)</span></span>&#123;</span><br><span class="line">        <span class="keyword">int</span> m = nums1.size();</span><br><span class="line">        <span class="keyword">int</span> n = nums2.size();</span><br><span class="line">        <span class="keyword">if</span>(m &gt; n)&#123;</span><br><span class="line">            nums1.swap(nums2);</span><br><span class="line">            <span class="keyword">int</span> temp = m;</span><br><span class="line">            m = n;</span><br><span class="line">            n = temp;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">int</span> iMin = <span class="number">0</span>, iMax = m, halfLen = (m + n + <span class="number">1</span>) / <span class="number">2</span>;</span><br><span class="line">        <span class="keyword">while</span>(iMin &lt;= iMax0)&#123;</span><br><span class="line">            <span class="keyword">int</span> i = (iMin + iMax) / <span class="number">2</span>;</span><br><span class="line">            <span class="keyword">int</span> j = halfLen - i;</span><br><span class="line">            <span class="keyword">if</span>(i &lt; iMax &amp;&amp; nums2[j<span class="number">-1</span>] &gt; nums1[i])&#123;</span><br><span class="line">                iMin = i + <span class="number">1</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">else</span> <span class="keyword">if</span>(i &gt; iMin &amp;&amp; nums1[i<span class="number">-1</span>] &gt; nums2[j])&#123;</span><br><span class="line">                iMax = i - <span class="number">1</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">else</span>&#123;</span><br><span class="line">                <span class="keyword">int</span> maxLeft = <span class="number">0</span>;</span><br><span class="line">                <span class="keyword">if</span>(i == <span class="number">0</span>)&#123;</span><br><span class="line">                    maxLeft = nums2[j<span class="number">-1</span>];</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="keyword">else</span> <span class="keyword">if</span>(j == <span class="number">0</span>)&#123;</span><br><span class="line">                    maxLeft = nums1[i<span class="number">-1</span>];</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="keyword">else</span>&#123;</span><br><span class="line">                    maxLeft = max(nums1[i<span class="number">-1</span>], nums2[j<span class="number">-1</span>]);</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="keyword">if</span>((m+n) % <span class="number">2</span> == <span class="number">1</span>)&#123;</span><br><span class="line">                    <span class="keyword">return</span> maxLeft;</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="keyword">int</span> minRigght = <span class="number">0</span>;</span><br><span class="line">                <span class="keyword">if</span>(i == m)&#123;</span><br><span class="line">                    minRight = nums2[j];</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="keyword">else</span> <span class="keyword">if</span>(j == n)&#123;</span><br><span class="line">                    minRight = nums1[i];</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="keyword">else</span>&#123;</span><br><span class="line">                    minRight = min(nums1[i], nums2[j]);</span><br><span class="line">                &#125;</span><br><span class="line">                </span><br><span class="line">                <span class="keyword">return</span> (maxLeft + minRight) / <span class="number">2.0</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="number">0.0</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>本题参考了Solution，本人能力有限，如有错误之处，欢迎批评指正。</p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;今天的题目是求两个有序数组的中位数，两个数组的长度分别是 $m$ 和 $n$ 。并要求时间复杂度为 $O(\log(m+n))$。我们假定两个数组均不为空。具体题目如下：
    
    </summary>
    
      <category term="学习笔记" scheme="http://yoursite.com/categories/%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/"/>
    
    
      <category term="LeetCode" scheme="http://yoursite.com/tags/LeetCode/"/>
    
      <category term="C++" scheme="http://yoursite.com/tags/C/"/>
    
  </entry>
  
  <entry>
    <title>LeetCode-04</title>
    <link href="http://yoursite.com/2019/10/01/LeetCode-04/"/>
    <id>http://yoursite.com/2019/10/01/LeetCode-04/</id>
    <published>2019-10-01T08:35:42.000Z</published>
    <updated>2019-10-04T15:09:54.020Z</updated>
    
    <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><script class="meting-secondary-script-marker" src="\assets\js\Meting.min.js"></script><p>今天的题目是一道关于字符串的问题。字符串在面试笔试中是出现频率较高的一种题型，所以对字符串的练习和掌握很有必要。今天的这道题目是找到无重复字符的最长子串。<a id="more"></a>题目如下：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Given a string, find the length of the longest substring without repeating characters.</span><br></pre></td></tr></table></figure><p><strong>Example 1:</strong></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">Input: &quot;abcabcbb&quot;</span><br><span class="line">Output: 3</span><br><span class="line">Explantion: The answer is &quot;abc&quot;, with the length of 3.</span><br></pre></td></tr></table></figure><p><strong>Example 2:</strong></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">Input: &quot;bbbb&quot;</span><br><span class="line">Output: 1</span><br><span class="line">Explanation: The answer is &quot;b&quot;, with the length of 1.</span><br></pre></td></tr></table></figure><p><strong>Example 3:</strong></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">Input: &quot;pwwkew&quot;</span><br><span class="line">Output: 3</span><br><span class="line">Explanation: The answer is &quot;wwke&quot;, with the length of 3.</span><br><span class="line">             Note that the answer must be a substring, &quot;pwke&quot; is a subsquence and not a substring.</span><br></pre></td></tr></table></figure><h2 id="解法一"><a href="#解法一" class="headerlink" title="解法一"></a>解法一</h2><p>本题的解答过程参考了LeetCode Solution。看到本题的第一思路就是暴力解法，即遍历所有的子串，看其中是否存在相同的字符。暴力求解算法如下所示：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>&#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">lengthOfLongestSubstring</span><span class="params">(<span class="built_in">string</span> s)</span></span>&#123;</span><br><span class="line">        <span class="keyword">int</span> n = s.length();</span><br><span class="line">        <span class="keyword">int</span> ans = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i =  <span class="number">0</span>; i &lt; n; i++)&#123;</span><br><span class="line">            <span class="keyword">for</span>(<span class="keyword">int</span> j = i+<span class="number">1</span>; j &lt;= n; j++)&#123;</span><br><span class="line">                <span class="keyword">if</span>(allUnique(s, i, j))&#123;</span><br><span class="line">                    ans = max(ans, j-i);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">bool</span> <span class="title">allUnique</span><span class="params">(<span class="built_in">string</span> s, <span class="keyword">int</span> start, <span class="keyword">int</span> end)</span></span>&#123;</span><br><span class="line">        <span class="built_in">set</span>&lt;<span class="keyword">char</span>&gt; <span class="built_in">set</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = start; i &lt; end; i++)&#123;</span><br><span class="line">            <span class="keyword">char</span> ch = s[i];</span><br><span class="line">            <span class="keyword">if</span>(<span class="built_in">set</span>.count(ch) == <span class="number">1</span>)&#123;</span><br><span class="line">                <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="built_in">set</span>.insert(ch);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>虽然这种暴力解法是最简单易懂的，但是这种方式在实际工作中是最不可取的，因为在面对一个很长的字符串时，其时间复杂度为O(n^3)。导致其执行时间过长，而无法在正常的时间内产生结果。所以必须优化暴力解法。</p><h2 id="解法二"><a href="#解法二" class="headerlink" title="解法二"></a>解法二</h2><p>第一种方式中我们遍历了所有的子串，并循环判断每个子串中是否含有相同的元素，这其中包含了很多重复的比较。比如说在判断子串 $S_(ij)$ 时，如果从索引 $i$ 到 $j-1$ 已经检查为没有重复的字符，则我们只需要判断 $s[j]$ 是够在子串 $S_(ij)$ 中即可。解法二中我们采用一种滑窗的方法来解决这个问题。初始化窗口 $[i,j)$ $(j = i)$，然后我们将索引 $j$ 向右移动，当遇到相同的元素时，我们将 $i+1$ 。代码如下：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>&#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">lengthOfLongestSubstring</span><span class="params">(<span class="built_in">string</span> s)</span></span>&#123;</span><br><span class="line">        <span class="keyword">int</span> n = s.length();</span><br><span class="line">        <span class="built_in">set</span>&lt;<span class="keyword">char</span>&gt; <span class="built_in">set</span>;</span><br><span class="line">        <span class="keyword">int</span> ans = <span class="number">0</span>, i = <span class="number">0</span>, j = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">while</span>(i &lt; n &amp;&amp; j &lt; n)&#123;</span><br><span class="line">            <span class="keyword">if</span>(<span class="built_in">set</span>.count(s[j] == <span class="number">0</span>))&#123;</span><br><span class="line">                <span class="built_in">set</span>.insert(s[j++]);</span><br><span class="line">                ans = max(ans, j-i);</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">else</span>&#123;</span><br><span class="line">                <span class="built_in">set</span>.erase(s[i++]);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> ans;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><h2 id="解法三"><a href="#解法三" class="headerlink" title="解法三"></a>解法三</h2><p>第二种解法虽然较第一种方式有了很大的改进，但是其中仍有一些冗余的比较。第二种解法中，在遇到相同的字符 $s[j^<em>]$之后，我们将索引 $i$ 向右加一。其实，我们可以直接移动到 $j^</em>+1$ 的位置，我们使用 $map$ 结构来记录索引，代码如下：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>&#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">lengthOfLongestSubstring</span><span class="params">(<span class="built_in">string</span> s)</span></span>&#123;</span><br><span class="line">        <span class="keyword">int</span> n = s.length();</span><br><span class="line">        <span class="keyword">int</span> ans = <span class="number">0</span>;</span><br><span class="line">        <span class="built_in">map</span>&lt;<span class="keyword">char</span>, <span class="keyword">int</span>&gt; <span class="built_in">map</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> j = <span class="number">0</span>, i = <span class="number">0</span>; j &lt; n; j++)&#123;</span><br><span class="line">            <span class="keyword">if</span>(<span class="built_in">map</span>.count(s[j]) == <span class="number">1</span>)&#123;</span><br><span class="line">                i = max(<span class="built_in">map</span>(s[j]), i);</span><br><span class="line">            &#125;</span><br><span class="line">            ans = max(ans, j - i + <span class="number">1</span>);</span><br><span class="line">            <span class="built_in">map</span>[s[j]] = j+<span class="number">1</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> ans;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><h2 id="解法四"><a href="#解法四" class="headerlink" title="解法四"></a>解法四</h2><p>第四种解法的思想和第三种的思想是一致的，只是使用一个数组来替换了上述解法的 $map$ 结构。代码如下所示。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>&#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">lengthOfLongestSubstring</span><span class="params">(<span class="built_in">string</span> s)</span></span>&#123;</span><br><span class="line">        <span class="keyword">int</span> n = s.length(), ans = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">int</span> *index = <span class="keyword">new</span> <span class="keyword">int</span>[<span class="number">256</span>];</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> j = <span class="number">0</span>, i = <span class="number">0</span>; j &lt; n; j++)&#123;</span><br><span class="line">            i = max(index[s[j]], i);</span><br><span class="line">            ans = max(ans, j-i+<span class="number">1</span>);</span><br><span class="line">            index[s[j]] = j+<span class="number">1</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> ans;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>本题参考LeetCode Solution解题过程，因本人能力有限，如有错误之处，欢迎批评指正。</p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;今天的题目是一道关于字符串的问题。字符串在面试笔试中是出现频率较高的一种题型，所以对字符串的练习和掌握很有必要。今天的这道题目是找到无重复字符的最长子串。
    
    </summary>
    
      <category term="学习笔记" scheme="http://yoursite.com/categories/%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/"/>
    
    
      <category term="LeetCode" scheme="http://yoursite.com/tags/LeetCode/"/>
    
      <category term="C++" scheme="http://yoursite.com/tags/C/"/>
    
  </entry>
  
  <entry>
    <title>LeetCode-03</title>
    <link href="http://yoursite.com/2019/10/01/LeetCode-03/"/>
    <id>http://yoursite.com/2019/10/01/LeetCode-03/</id>
    <published>2019-10-01T06:59:18.000Z</published>
    <updated>2019-10-01T08:26:57.420Z</updated>
    
    <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><script class="meting-secondary-script-marker" src="\assets\js\Meting.min.js"></script><p>今天的题目仍然是关于链表的问题，给定两个非空的链表，将两个链表相加。给定的链表存放的值是逆序的，题目详细信息如下：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">You are given two non-empty linked lists representing two non-negative integers. The digits are     </span><br><span class="line">stored in reverse order and each of their nodes contain a single digit. Add the two numbers and  </span><br><span class="line">return it as a linked list.</span><br></pre></td></tr></table></figure><p><strong>Example:</strong></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">Input: (2 -&gt; 4 -&gt; 3) + (5 -&gt; 6 -&gt; 4)</span><br><span class="line">Output: 7 -&gt; 0 -&gt; 8</span><br><span class="line">Explanation: 342 + 465 = 807.</span><br></pre></td></tr></table></figure><p>本题需要考虑的边界条件比较多，在两个链表长度相等的情况下较好处理，如果两个链表的长度不相等，则较短的链表的值相当于是0。同时，要考虑进位，如果两个链表相加的值大于9时，进位为1。对于链表指针也要注意处理。具体代码如下：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">ListNode</span>&#123;</span></span><br><span class="line">    <span class="keyword">int</span> val;</span><br><span class="line">    ListNode *next;</span><br><span class="line">    ListNode(<span class="keyword">int</span> x) : val(x), next(<span class="literal">nullptr</span>)&#123;&#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>&#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function">ListNode * <span class="title">addTwoNumbers</span><span class="params">(ListNode* l1, ListNode* l2)</span></span>&#123;</span><br><span class="line">        ListNode* dummyHead = <span class="keyword">new</span> ListNode(<span class="number">0</span>);</span><br><span class="line">        ListNode* p = l1, *q = l2, *curr = dummyHead;</span><br><span class="line">        <span class="keyword">int</span> carry = <span class="number">0</span>; <span class="comment">//进位</span></span><br><span class="line">        <span class="keyword">while</span>(p != <span class="literal">nullptr</span> || q != <span class="literal">nullptr</span>)&#123;</span><br><span class="line">            <span class="keyword">int</span> x = (p != <span class="literal">nullptr</span>) ? p-&gt;val : <span class="number">0</span>;</span><br><span class="line">            <span class="keyword">int</span> y = (q != <span class="literal">nullptr</span>) ? q-&gt;val : <span class="number">0</span>;</span><br><span class="line">            <span class="keyword">int</span> sum = x + y + carry;</span><br><span class="line">            carry = sum / <span class="number">10</span>;</span><br><span class="line">            curr-&gt;next = <span class="keyword">new</span> ListNode(sum % <span class="number">10</span>);</span><br><span class="line">            curr = curr-&gt;next;</span><br><span class="line">            <span class="keyword">if</span>(p != <span class="literal">nullptr</span>)&#123;</span><br><span class="line">                p = p-&gt;next;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span>(q != <span class="literal">nullptr</span>)&#123;</span><br><span class="line">                q = q-&gt;next;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span>(carry &gt; <span class="number">0</span>)&#123;</span><br><span class="line">            curr-&gt;next = <span class="keyword">new</span> ListNode(carry);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> dummyHead-&gt;next;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>本题答案参考了LeetCode solution，如有错误之处，欢迎批评指正。</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;link rel=&quot;stylesheet&quot; class=&quot;aplayer-secondary-style-marker&quot; href=&quot;\assets\css\APlayer.min.css&quot;&gt;&lt;script src=&quot;\assets\js\APlayer.min.js&quot; cla
      
    
    </summary>
    
      <category term="学习笔记" scheme="http://yoursite.com/categories/%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/"/>
    
    
      <category term="LeetCode" scheme="http://yoursite.com/tags/LeetCode/"/>
    
      <category term="C++" scheme="http://yoursite.com/tags/C/"/>
    
  </entry>
  
  <entry>
    <title>Python安装pandas的问题</title>
    <link href="http://yoursite.com/2019/09/30/%E9%97%AE%E9%A2%98%E8%AE%B0%E5%BD%95/"/>
    <id>http://yoursite.com/2019/09/30/问题记录/</id>
    <published>2019-09-30T08:40:19.000Z</published>
    <updated>2019-09-30T15:40:04.146Z</updated>
    
    <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><script class="meting-secondary-script-marker" src="\assets\js\Meting.min.js"></script><p>在Ubuntu下，安装caffe，并安装Python2的接口，中途安装pandas等库的时候遇到一些问题，在此记录。问题如下：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Command &quot;python setup.py egg_info&quot; failed with error code 1 in /tmp/pip-build*</span><br></pre></td></tr></table></figure><p>在网上搜寻相关问题后，大多数的解决方案是升级pip 和 setuptools，如下所示：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">sudo python -m pip install --upgrade --force pip</span><br><span class="line">sudo pip install setuptools==33.1.1</span><br></pre></td></tr></table></figure><p>尝试该方法后并未生效，最后发现，很多库如pandas已不再支持Python2，但是通过pip的方式安装时，仍然下载的是最新版本的库，所以会出错，在安装的时候指定版本即可解决该问题。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">pip2 install pandas==0.23.0</span><br></pre></td></tr></table></figure><p>目前很多库对Python2已不再支持，如numpy，Pytorch等等。但是在安装的过程中仍然会下载最新版本，这时可能会发生错误。所以在安装的时候需要指定版本。同时，在安装的过程中如果出现错误，也有肯能是权限问题导致，或者是版本的问题。如我在安装pandas和lmdb的时候，都是在sudo的条件下才安装成功的。环境问题有时看似是个简单的问题，但在很多时候也会产生各种各样的问题，需要我们仔细分析和谨慎处理。本人能力有限，如有错误和不当之处欢迎批评指正。</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;link rel=&quot;stylesheet&quot; class=&quot;aplayer-secondary-style-marker&quot; href=&quot;\assets\css\APlayer.min.css&quot;&gt;&lt;script src=&quot;\assets\js\APlayer.min.js&quot; cla
      
    
    </summary>
    
      <category term="学习笔记" scheme="http://yoursite.com/categories/%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/"/>
    
    
      <category term="Linux" scheme="http://yoursite.com/tags/Linux/"/>
    
      <category term="Python" scheme="http://yoursite.com/tags/Python/"/>
    
  </entry>
  
  <entry>
    <title>LeetCode_02　</title>
    <link href="http://yoursite.com/2019/09/28/LeetCode-02/"/>
    <id>http://yoursite.com/2019/09/28/LeetCode-02/</id>
    <published>2019-09-28T15:20:04.000Z</published>
    <updated>2019-09-29T02:39:47.307Z</updated>
    
    <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><script class="meting-secondary-script-marker" src="\assets\js\Meting.min.js"></script><p>　　今天的LeetCode题目为删除一个有序数组中的重复元素。初看这道题目的第一思路是，定义一个新的数组。for 循环给定数组，比较当前元素与前一个元素是否相等，如果相等，则继续向后比较，如果不相等，则将该元素置于新的数组中。这个方法虽然简单易懂，但是申请了额外的空间，所以并非是最优方法。伪代码如下：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">removeDuplicates</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&amp; nums)</span></span>&#123;</span><br><span class="line">    <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; result;</span><br><span class="line">    result.push_back(nums[<span class="number">0</span>])；</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">1</span>; i &lt; nums.size(); i++)&#123;</span><br><span class="line">        <span class="keyword">if</span>(nums[i] !== nums[i<span class="number">-1</span>])&#123;</span><br><span class="line">            result.push_back(nums[i]);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> result.size();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>　　在不申请额外空间的情况下如何删除相同的元素。换个角度理解就是如何将不相同的元素放置在相邻的位置。为了将不相同的元素移动到相邻的位置，我们便需要记录出现相同元素的位置，以便在出现不同的元素时，将其移到该位置。</p><p>　　解法一如下所示，我们使用了一个变量来记录出现相同元素的次数。以此来定位该放置的位置。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">removeDuplicates</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&amp; nums)</span></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> count = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">1</span>; i &lt; nums.size(); i++)&#123;</span><br><span class="line"><span class="keyword">if</span>(nums[i] == nums[i<span class="number">-1</span>])&#123;</span><br><span class="line">count++;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span>&#123;</span><br><span class="line">            nums[i-count] = nums[i];</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> nums.size()-count;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>　　解法二如下所示，我们定义一个变量来记录第一次出现相同元素的索引，一旦出现不同的元素，便将该元素移动到该索引值对应的位置。否则，该索引值保持不变。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">removeDuplicates</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&amp; nums)</span></span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(nums.size() = <span class="number">0</span>)&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">int</span> index = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; nums.size(); i++)&#123;</span><br><span class="line">        <span class="keyword">if</span>(nums[i] != nums[index])&#123;</span><br><span class="line">nums[index++] = nums[i];</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> index+<span class="number">1</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>同时，记录一下LeetCode中遇到的一个问题如下：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Runtime Error Message:reference binding to null pointer of type &apos;value_type&apos;</span><br></pre></td></tr></table></figure><p>这种情况可能为数组越界，也有可能是测试样例中的输入为空。因此，在程序处理之前，一定要判断输入是否为空，是否合法。本次遇到的问题就是由于未对输入数组的长度进行判断，加入判断数组长度是否为0即可。能力有限，如有错误之处，欢迎批评指正。</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;link rel=&quot;stylesheet&quot; class=&quot;aplayer-secondary-style-marker&quot; href=&quot;\assets\css\APlayer.min.css&quot;&gt;&lt;script src=&quot;\assets\js\APlayer.min.js&quot; cla
      
    
    </summary>
    
      <category term="学习笔记" scheme="http://yoursite.com/categories/%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/"/>
    
    
      <category term="LeetCode" scheme="http://yoursite.com/tags/LeetCode/"/>
    
  </entry>
  
  <entry>
    <title>LeetCode_01</title>
    <link href="http://yoursite.com/2019/09/27/LeetCode-01/"/>
    <id>http://yoursite.com/2019/09/27/LeetCode-01/</id>
    <published>2019-09-27T13:31:19.000Z</published>
    <updated>2019-09-27T15:24:12.312Z</updated>
    
    <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><script class="meting-secondary-script-marker" src="\assets\js\Meting.min.js"></script><h2 id="链表合并"><a href="#链表合并" class="headerlink" title="链表合并"></a><center>链表合并</center></h2><p>　　步入研究生的第二年，也即将面临就业问题。做每一件事情都需要未雨绸缪，做好准备才不会错失每个机会。<a id="more"></a>因此，本学年，我计划在LeetCode每日一题，一方面也巩固一下自己以前学到的算法和数据结构。今天是第一道题，是关于有序链表合并的问题。链表是线性表结构的一种表示方式，也是很重要的一种数据结构。在本科的数据结构课程中也是第一章内容。</p><p>　　题目描述如下：</p><p>Merge two sorted linked lists and return it as a new list. The new list should be made by splicing together the nodes of the first two lists. </p><p><strong>Example：</strong></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">Input: 1-&gt;2-&gt;4, 1-&gt;3-&gt;4</span><br><span class="line">Output: 1-&gt;1-&gt;2-&gt;3-&gt;4-&gt;</span><br></pre></td></tr></table></figure><ul><li><p>解题思路</p><p>单链表的定义如下：</p></li></ul><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">ListNode</span>&#123;</span></span><br><span class="line"><span class="keyword">int</span> val;</span><br><span class="line">ListNode *next;</span><br><span class="line">ListNode(<span class="keyword">int</span> x) : val(x), next(<span class="literal">NULL</span>) &#123;&#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>合并两个链表前首先判断两个链表是否为空，在不为空的条件下，比较两个链表的值，并将较小的链接到第三个链表，相应的指针向后移动。代码示例如下：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>&#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line"><span class="function">ListNode* <span class="title">mergeTwoLists</span><span class="params">(ListNode* l1, ListNode* l2)</span></span>&#123;</span><br><span class="line"><span class="keyword">if</span>(l1 == <span class="literal">nullptr</span>)&#123;</span><br><span class="line"><span class="keyword">return</span> l2;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span>(l2 == <span class="literal">nullptr</span>)&#123;</span><br><span class="line">            <span class="keyword">return</span> l1;</span><br><span class="line">        &#125;</span><br><span class="line">        ListNode* result = <span class="literal">nullptr</span>;</span><br><span class="line">        <span class="keyword">if</span>(l1-&gt;val &lt;= l2-&gt; val)&#123;</span><br><span class="line">            result = l1;</span><br><span class="line">            l1 = l1-&gt;next;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span>&#123;</span><br><span class="line">            result = l2;</span><br><span class="line">            l2 = l2-&gt;next;</span><br><span class="line">        &#125;</span><br><span class="line">        ListNode* r = result;</span><br><span class="line">        <span class="keyword">while</span>(l1 &amp;&amp; l2)&#123;</span><br><span class="line">            <span class="keyword">if</span>(l1-&gt;val &lt;= l2-&gt;val)&#123;</span><br><span class="line">                r-&gt;next = l1;</span><br><span class="line">                l1 = l1-&gt;next;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">else</span>&#123;</span><br><span class="line">                r-&gt;next = l2;</span><br><span class="line">                l2 = l2-&gt;next;</span><br><span class="line">            &#125;</span><br><span class="line">            r = r-&gt;next;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span>(l1)&#123;</span><br><span class="line">            r-&gt;next = l1;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span>&#123;</span><br><span class="line">            r-&gt;next = l2;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> result;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>数据结构线性表中的知识点还有很多，如双链表，循环链表，链表的增删改查等，都是必须熟练掌握的，我会在后续的过程中对这些知识点进行更新。本人能力有限，如有错误之处，欢迎指出。</p>]]></content>
    
    <summary type="html">
    
      &lt;h2 id=&quot;链表合并&quot;&gt;&lt;a href=&quot;#链表合并&quot; class=&quot;headerlink&quot; title=&quot;链表合并&quot;&gt;&lt;/a&gt;&lt;center&gt;链表合并&lt;/center&gt;&lt;/h2&gt;&lt;p&gt;　　步入研究生的第二年，也即将面临就业问题。做每一件事情都需要未雨绸缪，做好准备才不会错失每个机会。
    
    </summary>
    
      <category term="学习笔记" scheme="http://yoursite.com/categories/%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/"/>
    
    
      <category term="LeetCode" scheme="http://yoursite.com/tags/LeetCode/"/>
    
  </entry>
  
  <entry>
    <title>回首</title>
    <link href="http://yoursite.com/2019/07/13/%E5%9B%9E%E9%A6%96/"/>
    <id>http://yoursite.com/2019/07/13/回首/</id>
    <published>2019-07-13T15:59:27.000Z</published>
    <updated>2019-09-27T13:43:36.179Z</updated>
    
    <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><script class="meting-secondary-script-marker" src="\assets\js\Meting.min.js"></script><h2 id="博客回归"><a href="#博客回归" class="headerlink" title="博客回归"></a><center>博客回归</center></h2><p><img src="http://ssyerv1.oss-cn-hangzhou.aliyuncs.com/picture/879865b5567349ab96c06716de97085a.jpg" alt=" "></p><p>　　不知不觉，2019年已过去多半，回首过去的这一年，茫茫然然，也明白了很多事情。还记得刚开通博客的初衷是为了记录自己在学习和生活中的点点滴滴。<a id="more"></a>这一年的研究生涯却并不顺利，便疏忽了对博客的更新。实为惭愧。2019年，是建国的70周年。正值国庆来临之际，举国欢庆之时。突然觉得以前的自己错失了很多把事情做好的机会。便想着在这个时刻，以这里为起点，开启一个新的征程。</p><p>　　当初建立博客的定位是作为一个技术博客。所以在这新的一年研究生涯中，博客更新的主要内容可能是技术相关的话题。用来记录自己在学习过程中的一些感悟和问题。同时，也会不定期的更新自己的一些随想。这一学年，由于毕业设计的开题，做的应该是高级综合。所以内容多为HLS（高级综合）以及FPGA相关知识。也会涉及一些神经网络方面相关的知识。下一学年要面对就业，所以在这个过程中也会更新有关算法，c++，操作系统或是数据结构的相关内容。</p><p>​　　制定一件事情很容易，但要坚持下去，却是一件很难的事情，希望每日的博客也能作为对自己的鞭策，把一件事情坚持下去，做到尽力，做到更好。我相信，明天一定会更好。</p>]]></content>
    
    <summary type="html">
    
      &lt;h2 id=&quot;博客回归&quot;&gt;&lt;a href=&quot;#博客回归&quot; class=&quot;headerlink&quot; title=&quot;博客回归&quot;&gt;&lt;/a&gt;&lt;center&gt;博客回归&lt;/center&gt;&lt;/h2&gt;&lt;p&gt;&lt;img src=&quot;http://ssyerv1.oss-cn-hangzhou.aliyuncs.com/picture/879865b5567349ab96c06716de97085a.jpg&quot; alt=&quot; &quot;&gt;&lt;/p&gt;
&lt;p&gt;　　不知不觉，2019年已过去多半，回首过去的这一年，茫茫然然，也明白了很多事情。还记得刚开通博客的初衷是为了记录自己在学习和生活中的点点滴滴。
    
    </summary>
    
      <category term="浮生日记" scheme="http://yoursite.com/categories/%E6%B5%AE%E7%94%9F%E6%97%A5%E8%AE%B0/"/>
    
    
      <category term="life" scheme="http://yoursite.com/tags/life/"/>
    
  </entry>
  
  <entry>
    <title>无题2</title>
    <link href="http://yoursite.com/2018/06/14/%E6%97%A0%E9%A2%982/"/>
    <id>http://yoursite.com/2018/06/14/无题2/</id>
    <published>2018-06-14T13:22:02.000Z</published>
    <updated>2018-06-14T15:05:07.725Z</updated>
    
    <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><script class="meting-secondary-script-marker" src="\assets\js\Meting.min.js"></script><center>翻阅手机，偶遇数好句，与君分享</center><p><img src="https://cdn.pixabay.com/photo/2017/09/08/02/24/chess-2727443__340.jpg" alt=""><a id="more"></a></p><p>人生是个含泪的微笑。</p><p>　　　　　　　　　　　　　　　　　　　　　　　　　　　　　　　　　　　　　　　　　　－－欧·亨利</p><p>我愿深深地扎入生活，吮尽生活的骨髓，过的扎实，简单，把一切不属于生活的内容剔除的干净利落，把生活逼到绝处，简单最基本的形式，简单，简单，再简单。</p><p>　　　　　　　　　　　　　　　　　　　　　　　　　　　　　　　　　　　　　　　　　　－－梭罗</p><p>这些墙很有趣。刚入狱的时候，你痛恨周围的高墙；慢慢地，你习惯了生活在其中；最终你会发现自己不得不依靠它而生存。这就叫体制化。</p><p>　　　　　　　　　　　　　　　　　　　　　　　　　　　　　　　　　　　　　　　　　　－－斯蒂芬·金</p><p>我只喜欢一类人，他们生活狂放不羁说起话来热情洋溢，对生活十分苛刻，希望拥有一切，他们对平凡的事不屑一顾，但他们渴望燃烧，像神话中巨型的黄色罗马蜡烛那样燃烧，渴望爆炸，像行星抨击那样在爆炸声中发出蓝色的光，令人惊叹不已。</p><p>　　　　　　　　　　　　　　　　　　　　　　　　　　　　　　　　　　　　　　　　　　－－杰克·凯鲁亚克</p><p>时间是最厉害的杀手，人们遗忘，厌倦，变老，离去。她说，用历史的眼光看，我们之间其实也没多少事。</p><p>　　　　　　　　　　　　　　　　　　　　　　　　　　　　　　　　　　　　　　　　　　－－詹妮特·温特森</p><p>做孩子的时候感到无聊，盼望着长大。长大后又向往返回童年。我们浪费自己的健康去赢得个人的财富，然后又浪费自己的财富去重建自身的健康。我们焦虑地憧憬未来，忘记了眼前的生活。活的既不是为了现在也不是为了将来。我们活的似乎永远不会死，我们死的也好像从来没活过。</p><p>　　　　　　　　　　　　　　　　　　　　　　　　　　　　　　　　　　　　　　　　　　－－多丽丝·莱辛</p>    <div id="aplayer-DRHahsmp" class="aplayer aplayer-tag-marker meting-tag-marker" data-id="154402" data-server="netease" data-type="song" data-mode="circulation" data-autoplay="true" data-mutex="true" data-listmaxheight="340px" data-preload="auto" data-theme="#ad7a86"></div>]]></content>
    
    <summary type="html">
    
      &lt;center&gt;翻阅手机，偶遇数好句，与君分享&lt;/center&gt;

&lt;p&gt;&lt;img src=&quot;https://cdn.pixabay.com/photo/2017/09/08/02/24/chess-2727443__340.jpg&quot; alt=&quot;&quot;&gt;
    
    </summary>
    
      <category term="浮生日记" scheme="http://yoursite.com/categories/%E6%B5%AE%E7%94%9F%E6%97%A5%E8%AE%B0/"/>
    
    
      <category term="life" scheme="http://yoursite.com/tags/life/"/>
    
  </entry>
  
  <entry>
    <title>Opencv安装</title>
    <link href="http://yoursite.com/2018/05/22/Opencv/"/>
    <id>http://yoursite.com/2018/05/22/Opencv/</id>
    <published>2018-05-22T03:51:31.000Z</published>
    <updated>2018-05-22T04:55:00.496Z</updated>
    
    <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><script class="meting-secondary-script-marker" src="\assets\js\Meting.min.js"></script><h1 id="Ubuntu16-04安装Opencv和contrib"><a href="#Ubuntu16-04安装Opencv和contrib" class="headerlink" title="Ubuntu16.04安装Opencv和contrib"></a><center>Ubuntu16.04安装Opencv和contrib</center></h1><a id="more"></a><h2 id="更新"><a href="#更新" class="headerlink" title="更新"></a>更新</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">sudo apt-get update</span><br><span class="line">sudo apt-get upgrade</span><br></pre></td></tr></table></figure><h2 id="安装依赖包"><a href="#安装依赖包" class="headerlink" title="安装依赖包"></a>安装依赖包</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">sudo apt-get install build-essential</span><br><span class="line">sudo apt-get install cmake git libgtk2.0-dev pkg-config libavcodec-dev libavformat-dev libswscale-dev</span><br><span class="line">sudo apt-get install python-dev python-numpy libtbb2 libtbb-dev libjpeg8-dev libpng12-dev libtiff5-dev libjasper-dev libdc1394-22-dev #图像处理所需的包</span><br><span class="line">sudo apt-get install libavcodec-dev libavformat-dev libswscale-dev libv4l-dev liblapacke-dev</span><br><span class="line">sudo apt-get install libxvidcore-dev libx264-dev</span><br><span class="line">sudo apt-get install libatlas-base-dev gfortran</span><br><span class="line">sudo apt-get isstall ffmpeg</span><br><span class="line">sudo apt-get install libgtk-3-dev</span><br><span class="line">sudo apt-get install python3.5-dev</span><br></pre></td></tr></table></figure><h2 id="下载Opencv源码"><a href="#下载Opencv源码" class="headerlink" title="下载Opencv源码"></a>下载Opencv源码</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">wget https://github.com/opencv/opencv/archive/3.3.1.zip</span><br><span class="line">wget https://github.com/opencv/opencv_contrib/archive/3.3.1.zip</span><br></pre></td></tr></table></figure><h2 id="编译"><a href="#编译" class="headerlink" title="编译"></a>编译</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">cd opencv-3.3.1</span><br><span class="line">mkdir build</span><br><span class="line">cd build</span><br><span class="line">cmake -D CMAKE_BUILD_TYPE=RELEASE \</span><br><span class="line">-D CMAKE_INSTALL_PREFIX=/usr/local \</span><br><span class="line">-D INSTALL_PYTHON_EXAMPLES=ON \</span><br><span class="line">-D INSTALL_C_EXAMPLES=OFF \</span><br><span class="line">-D OPENCV_EXTRA_MODULES_PATH=~/opencv_contrib-3.3.1/modules \</span><br><span class="line">-D PYTHON_EXCUTABLE=/usr/local/bin/python3 \</span><br><span class="line">-D WITH_TBB=OFF \</span><br><span class="line">-D WITH_V4L=OFF \</span><br><span class="line">-D WITH_QT=OFF \</span><br><span class="line">-D WITH_GTK=OFF \</span><br><span class="line">-D WITH_OPENGL=OFF \</span><br><span class="line">-D BUILD_EXAMPLES=ON ..</span><br></pre></td></tr></table></figure><h2 id="安装"><a href="#安装" class="headerlink" title="安装"></a>安装</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">make -j4</span><br><span class="line">sudo make install</span><br></pre></td></tr></table></figure><h2 id="测试"><a href="#测试" class="headerlink" title="测试"></a>测试</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">python3</span><br><span class="line">import cv2</span><br><span class="line">print(cv2.__version__)</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      &lt;h1 id=&quot;Ubuntu16-04安装Opencv和contrib&quot;&gt;&lt;a href=&quot;#Ubuntu16-04安装Opencv和contrib&quot; class=&quot;headerlink&quot; title=&quot;Ubuntu16.04安装Opencv和contrib&quot;&gt;&lt;/a&gt;&lt;center&gt;Ubuntu16.04安装Opencv和contrib&lt;/center&gt;&lt;/h1&gt;
    
    </summary>
    
      <category term="学习笔记" scheme="http://yoursite.com/categories/%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/"/>
    
    
      <category term="opencv" scheme="http://yoursite.com/tags/opencv/"/>
    
  </entry>
  
  <entry>
    <title>醒来</title>
    <link href="http://yoursite.com/2018/05/14/%E9%86%92%E6%9D%A5/"/>
    <id>http://yoursite.com/2018/05/14/醒来/</id>
    <published>2018-05-14T03:37:20.000Z</published>
    <updated>2019-07-13T16:02:31.725Z</updated>
    
    <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><script class="meting-secondary-script-marker" src="\assets\js\Meting.min.js"></script><center>上帝喜欢开玩笑，人生已然变成一个荒唐的笑话!</center><p><img src="https://cdn.pixabay.com/photo/2017/03/10/09/14/alarm-clock-2132264__340.jpg" alt=""><a id="more"></a></p><center>从生到死有多远<br><br>呼吸之间<br><br>从迷到悟有多远<br><br>一念之间<br><br>从爱到恨有多远<br><br>无常之间<br><br>从古到今有多远<br><br>笑谈之间<br><br>从你到我有多远<br><br>善解之间<br><br>从心到心有多远<br><br>天地之间<br><br>当欢场变成荒台<br><br>当新欢笑着旧爱<br><br>当记忆飘落尘埃<br><br>当一切是不可得空白<br><br>人生是多么无常的醒来<br><br>人生是无常的醒来</center>    <div id="aplayer-WQNiQGuw" class="aplayer aplayer-tag-marker meting-tag-marker" data-id="29755301" data-server="netease" data-type="song" data-mode="circulation" data-autoplay="true" data-mutex="true" data-listmaxheight="340px" data-preload="auto" data-theme="#ad7a86"></div>]]></content>
    
    <summary type="html">
    
      &lt;center&gt;上帝喜欢开玩笑，人生已然变成一个荒唐的笑话!&lt;/center&gt;

&lt;p&gt;&lt;img src=&quot;https://cdn.pixabay.com/photo/2017/03/10/09/14/alarm-clock-2132264__340.jpg&quot; alt=&quot;&quot;&gt;
    
    </summary>
    
      <category term="life" scheme="http://yoursite.com/categories/life/"/>
    
    
      <category term="音乐" scheme="http://yoursite.com/tags/%E9%9F%B3%E4%B9%90/"/>
    
  </entry>
  
  <entry>
    <title>写给来不及长大的孩子们</title>
    <link href="http://yoursite.com/2018/04/28/%E6%97%A0%E9%A2%981/"/>
    <id>http://yoursite.com/2018/04/28/无题1/</id>
    <published>2018-04-28T02:03:31.000Z</published>
    <updated>2018-04-28T03:22:17.771Z</updated>
    
    <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><script class="meting-secondary-script-marker" src="\assets\js\Meting.min.js"></script><p>　　<img src="https://cdn.pixabay.com/photo/2016/04/22/19/23/memory-1346375__340.jpg" alt=""></p><p>　　一阵急促的电话声将思绪拉回了现实，是大姐打过来的，告诉我出门多加小心，米脂发生了恶性砍人事件<a id="more"></a>，数十名学生伤亡。拿起手机才看到这个消息早已铺天盖地。</p><p>　　<img src="/images/米脂事件.jpg" width="200" height="100" alt="图片名称" align="center"></p><p>　　这件事情发生在陕北的黄土地上。陕北自古以来就是一片贫瘠与荒凉的土地，贫穷与苦难似乎从未在这片土地上消失。上天的眷顾对于生活在这里的人民而言，可望而不可即。可这次上天却偏偏与这里的人民开了一个不小的玩笑。一朵朵还未绽放美丽的花朵在一场突如其来的暴风雨中纷纷凋零。可春天才刚刚到来啊。还记得在上篇文章中说过，人总是个矛盾体，小时候总盼望着长大，可长大后又总希望回到小时候。如今，我依然可以希望自己回到小时候，可有的人却再也无法长大，再也没有机会盼望长大，也再没有机会去体验人世的繁华与落寞。面对这残酷的现实，我无能为力，仅以此文作为与他们的告别，希望他们在那遥远的世界不再拥有暴风雨。</p><p>　　一个平平常常的日子</p><p>　　你们一如既往的在教室里等待放学的铃声</p><p>　　可今天你们却比往常激动些许</p><p>　　因为，明天就是五一假期了</p><p>　　默念着一分一秒</p><p>　　心早已飞到了家里</p><p>　　飞到了母亲为你准备的菜肴里</p><p>　　飞到了父亲为你准备的玩具里</p><p>　　你还没有忘记</p><p>　　爸爸妈妈要带你去动物园</p><p>　　带你去游乐园呢</p><p>　　铃声终于响了，你们如箭一般</p><p>　　冲出了教室</p><p>　　三五成群的奔向了回家的路</p><p>　　可今天回家的路却异常的遥远，异常的长久</p><p>　　一条恶狗挡住了你们的去路</p><p>　　你们惊慌失措，四散逃走</p><p>　　哭喊着：快跑、快跑啊</p><p>　　可你们还是慢了</p><p>　　在恶狗的撕咬下</p><p>　　你们倒在了血泊之中</p><p>　　焦躁的父母沿路寻来</p><p>　　赶走了恶狗</p><p>　　抱起血泊中的你声嘶力竭</p><p>　　可这一切，你都无动于衷</p><p>　　你是不是累了</p><p>　　你是不是睡着了</p><p>　　你是不是做了一个很长很长的梦</p><p>　　在梦里你去了一个很远很远的地方</p><p>　　那里没有繁重的作业</p><p>　　也没有丑陋的恶狗</p><p>　　只有阳光与露水的沐浴</p><p>　　如若真是这样</p><p>　　你一定要记着到爸爸妈妈的梦里来</p><p>　　告诉他们，在那里，你很好，好吗</p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;　　&lt;img src=&quot;https://cdn.pixabay.com/photo/2016/04/22/19/23/memory-1346375__340.jpg&quot; alt=&quot;&quot;&gt;&lt;/p&gt;
&lt;p&gt;　　一阵急促的电话声将思绪拉回了现实，是大姐打过来的，告诉我出门多加小心，米脂发生了恶性砍人事件
    
    </summary>
    
      <category term="浮生日记" scheme="http://yoursite.com/categories/%E6%B5%AE%E7%94%9F%E6%97%A5%E8%AE%B0/"/>
    
    
      <category term="life" scheme="http://yoursite.com/tags/life/"/>
    
  </entry>
  
  <entry>
    <title>图像压缩之JPEG-LS算法理解</title>
    <link href="http://yoursite.com/2018/04/26/%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/"/>
    <id>http://yoursite.com/2018/04/26/学习笔记/</id>
    <published>2018-04-26T02:33:50.000Z</published>
    <updated>2018-06-14T14:32:13.894Z</updated>
    
    <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><script class="meting-secondary-script-marker" src="\assets\js\Meting.min.js"></script><p>　　<img src="https://cdn.pixabay.com/photo/2017/10/26/17/51/under-2891888__340.jpg" alt=""></p><h2 id="算法概述"><a href="#算法概述" class="headerlink" title="算法概述"></a>算法概述</h2><p>　　互联网的发展很多时候得益于多媒体信息的繁荣，而图像作为多媒体信息的组成部分占据着很重要的作用。但是<a id="more"></a>图像所占据的存储空间也越来越大，对于数据的传输和存储都带来了很大的压力。因此，图像压缩这一领域应势而生。图像压缩分为有损压缩和无损压缩。有损压缩会消除一部分冗余信息，但不会影响视觉感受，所以压缩比较高。而无损压缩则应用于对图像要求较高的航天及医学等领域。本文主要介绍无损压缩中的JPEG-LS算法。</p><p>　　JPEG-LS为JPEG的无损/近无损压缩新标准，于1994年开始征集算法提案，1998年2月ITU-T建议T.87（草案）正式公布，用于取代原JPEG的连续色调静止图像的无损压缩模式。</p><p>　　JPEG-LS压缩主要分为三大模块，一是预测，二是上下文建模，三是编码。框图如下：</p><p><img src="/images/流程框图.png" align="center"></p><h2 id="算法详解"><a href="#算法详解" class="headerlink" title="算法详解"></a>算法详解</h2><p>　　JPEG-LS包含一个非线性边缘检测器，可对水平边缘和垂直边缘进行检测。</p><p><img src="/images/像素.png" align="center"></p><p>　　通过当前像素值ｘ的领域像素来计算梯度值，如下所示：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">D1 = Xd - Xb;</span><br><span class="line">D2 = Xb - Xc;</span><br><span class="line">D3 = Xc - Xa;</span><br></pre></td></tr></table></figure><p>　　计算梯度值后对梯度值进行量化，通过量化后的梯度值构建上下文模型，并选择编码方式。在JPEG-LS算法中，常规模式下使用哥伦布编码，当进入较为平坦的区域时，将选择游程编码的方式。</p><p>　　### 像素值预测</p><p>　　像素值预测基于梯度检测，其预测过程如下所示：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">if Xc &gt;= max(Xa, Xb)</span><br><span class="line">    Px = min(Xa, Xb);</span><br><span class="line">else if Xc &lt;= min(Xa, Xb)</span><br><span class="line">    Px = max(Xa, Xb);</span><br><span class="line">else</span><br><span class="line">    Px = Xa + Xb - Xc;</span><br></pre></td></tr></table></figure><p>　　然后对预测值进行修正，将其映射到[0, maxvalue]之间。计算预测残差值，同样对预测残差值进行映射，之后便可进入编码过程，对数据进行压缩。</p><h3 id="哥伦布编码"><a href="#哥伦布编码" class="headerlink" title="哥伦布编码"></a>哥伦布编码</h3><p>　　在JPEG-LS中使用哥伦布编码，哥伦布编码由两部分组成，分别是n/m的二元码表示和n mod m的二进制直接表示。Rice提出当参数m为2的幂次时，可使计算过程大大简化。因此在哥伦布编码的过程中需要计算一个参数k，其计算如下：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">for(k = 0; (N[Q] &lt;&lt; k) &lt; A[Q]; k++)</span><br></pre></td></tr></table></figure><p>其中N[Q]表示到目前为止，出现的残差数目，而A[Q]则是到目前为止，对量化残差绝对值的累计值。</p><p>　　在编码的过程中，为了防止编码长度过长，影响压缩效率。会初始化一个最长编码长度。同时，会设置一个阈值N0，当N达到这个阈值时，便对相关变量进行重置。</p><h2 id="算法优化"><a href="#算法优化" class="headerlink" title="算法优化"></a>算法优化</h2><p>　　JPEG-LS虽然是一种低复杂度的算法，但是其性能仍有诸多地方可进行优化。JPEG-LS算法在提出时为了考虑复杂度，便使用了复杂度较低的哥伦布编码，其性能差于算术编码。因此，可以考虑使用算术编码替换原有编码方式。</p><p>　　另一方面，JPEG-LS使用的边缘检测器只能对水平边缘和垂直边缘进行检测。因此，可以考虑加入对角线检测的模式。</p><p>　　水平边缘检测模式如下所示：</p><p><img src="/images/水平.png" align="center"></p><p>　　可加入对角线检测模式，如下所示：</p><p><img src="/images/对角线.png" align="center"></p><h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p>　　JPEG-LS算法是一种低复杂度的无损/近无损压缩算法。其核心思想是使用预测编码的思想。目前，随着深度学习的不断兴起，也出现了使用神经网络对图像进行压缩的方法。因此，如何利用好这种方法来对图像进行压缩将是后续的研究方向。</p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;　　&lt;img src=&quot;https://cdn.pixabay.com/photo/2017/10/26/17/51/under-2891888__340.jpg&quot; alt=&quot;&quot;&gt;&lt;/p&gt;
&lt;h2 id=&quot;算法概述&quot;&gt;&lt;a href=&quot;#算法概述&quot; class=&quot;headerlink&quot; title=&quot;算法概述&quot;&gt;&lt;/a&gt;算法概述&lt;/h2&gt;&lt;p&gt;　　互联网的发展很多时候得益于多媒体信息的繁荣，而图像作为多媒体信息的组成部分占据着很重要的作用。但是
    
    </summary>
    
      <category term="学习笔记" scheme="http://yoursite.com/categories/%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/"/>
    
    
      <category term="JPEG-LS" scheme="http://yoursite.com/tags/JPEG-LS/"/>
    
      <category term="无损压缩" scheme="http://yoursite.com/tags/%E6%97%A0%E6%8D%9F%E5%8E%8B%E7%BC%A9/"/>
    
  </entry>
  
  <entry>
    <title>无题</title>
    <link href="http://yoursite.com/2018/04/23/%E6%97%A0%E9%A2%98/"/>
    <id>http://yoursite.com/2018/04/23/无题/</id>
    <published>2018-04-23T08:22:23.000Z</published>
    <updated>2018-04-24T04:26:53.472Z</updated>
    
    <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><script class="meting-secondary-script-marker" src="\assets\js\Meting.min.js"></script><p><img src="https://cdn.pixabay.com/photo/2015/06/22/08/39/child-817371__340.jpg" alt="avator"></p><p>　　深夜即将入睡的时候，听到隔壁小孩不停的哭着喊妈妈，倏忽发现自己已逾弱冠之年，早已不再拥有哭泣和寻求<a id="more"></a>母亲安慰的资格。人总是个矛盾体，小时候总盼望着自己能够长大，赶快脱离大人的说教与管制，总以为长大了就自由了，殊不知越长大，自由也随之越远。如今二十余载的春秋眨眼无存，也逐渐感受到了成人的压力，又极度的想回到童年里去，并希望自己不再长大。</p><p> 　　时常羡慕那些年幼懵懂的孩子，他们的快乐总是那样的简单，一堵墙、一颗球、一颗石子，亦或是一只蚂蚁都可以是一早上或是一个下午的快乐。行色匆匆的路人不停的经过，却全然不会打扰到他们的快乐。有时候，孩子们的快乐就是这样的简单。</p><p>　　租住的房子在小区一楼，窗外有几棵绿色的植物。每当有风吹过的时候，它们就变得热闹起来。此时，我便会打开收音机，漫不经心的听着，然后看着窗外，看着他们嬉戏打闹，看着他们窃窃私语，如若没有琐事打扰，这样的行为便可能持续一个早上或是一个下午。而这也便是我在这喧嚣的世界与忙碌的学习生活中常有的娱乐活动，也是我快乐的来源之一。想来我和那些年幼的孩子似乎并无两样。如此一来，心中又突然轻松了些许。</p><p>　　海子曾说：从明天起，做一个幸福的人；喂马、劈柴，周游世界；从明天起，关心粮食和蔬菜；我有一所房子，面朝大海，春暖花开。曾有一个孩子问我，你将来想做什么，我如是回答，那孩子却乐了，说那你怎么吃饭，如果有钱谁不想过这样的生活。是啊，这可能是个问题，在这滚滚红尘中的凡夫俗子，面对的第一个问题当然是吃饭。可有时候，我们却用了自己的一生去解决这个问题，待时光尽逝，回首往昔，空留一身疲惫。然后再将这个问题留给子孙，如此反复循环，生生不息。</p><p>　　仔细想来，这个问题其实并不难，很多时候我们是受困于社会这个大的框架下。而我们中的大多数都无法脱离于或是不敢脱离于这个框架。当然也有一些人不想脱离于这个框架，因为他们在这之中游刃有余，怡然自得。有时扪心自问，我敢于脱离、我想脱离或者我能脱离吗，答案不得而知，但我觉得极有可能是否定的。人真正的名字叫做欲望，也许我们都想从这个体制、这个框架中获得一些吧，倘若经过千百般努力仍不可得，痛苦、压力便由此产生。从而对以往无忧无虑的时光产生怀念。想来孩子的快乐之所以容易获得，也许正是因为他们没有过多的欲望吧！</p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;&lt;img src=&quot;https://cdn.pixabay.com/photo/2015/06/22/08/39/child-817371__340.jpg&quot; alt=&quot;avator&quot;&gt;&lt;/p&gt;
&lt;p&gt;　　深夜即将入睡的时候，听到隔壁小孩不停的哭着喊妈妈，倏忽发现自己已逾弱冠之年，早已不再拥有哭泣和寻求
    
    </summary>
    
      <category term="浮生日记" scheme="http://yoursite.com/categories/%E6%B5%AE%E7%94%9F%E6%97%A5%E8%AE%B0/"/>
    
    
      <category term="思想" scheme="http://yoursite.com/tags/%E6%80%9D%E6%83%B3/"/>
    
  </entry>
  
</feed>
